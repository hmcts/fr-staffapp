# Ruby
# Package your Ruby project.
# Add steps that install rails, analyze code, save build artifacts, deploy, and more:
# https://docs.microsoft.com/azure/devops/pipelines/languages/ruby

name: '$(SourceBranchName)-$(Build.SourceVersion) Build-$(Build.BuildId)'

trigger:
  batch: true
  branches:
    include:
      - master
  tags:
    include:
    - v*

pr:
  autoCancel: true
  branches:
    include:
      - master
      - feature/*
      - system/*

variables:
  application.name: 'hwf-staff'
  azure.subscription.endpoint: 'hmcts-pet'
  manual.branch.prefix: 'master'
  GOVUK_NOTIFY_API_KEY: ''
  NOTIFY_COMPLETED_NEW_REFUND_TEMPLATE_ID: 'template1'
  NOTIFY_COMPLETED_ONLINE_TEMPLATE_ID: 'template2'
  NOTIFY_COMPLETED_PAPER_TEMPLATE_ID: 'template3'
  NOTIFY_COMPLETED_CY_NEW_REFUND_TEMPLATE_ID: 'template4'
  NOTIFY_COMPLETED_CY_ONLINE_TEMPLATE_ID: 'template5'
  NOTIFY_COMPLETED_CY_PAPER_TEMPLATE_ID: 'template6'

jobs:
  - job: BuildAndTestApplication
    pool:
      vmImage: 'Ubuntu-22.04'
    steps:
      - task: Docker@1
        displayName: login
        inputs:
          azureSubscriptionEndpoint: '$(azure.subscription.endpoint)'
          azureContainerRegistry: $(azure.container.registry)
          command: login
      - bash: |
          branch_name=$(echo $(Build.SourceBranchName) | tr '[:upper:]' '[:lower:]')
          repo_sha=$(git rev-parse --verify HEAD)
          docker_image_tag_sha=${repo_sha:0:7}
          echo "##vso[task.setvariable variable=DOCKER_TAG;isOutput=true]${branch_name}-${docker_image_tag_sha}"
        displayName: 'Get Docker Tag (non manual push)'
        name: 'getDockerTag2'
        condition: or(eq(variables['Build.SourceBranch'], 'refs/heads/develop'), ne(variables['Build.Reason'], 'Manual'))
      - bash: |
          branch_name=$(echo $(Build.SourceBranchName) | tr '[:upper:]' '[:lower:]')
          repo_sha=$(git rev-parse --verify HEAD)
          docker_image_tag_sha=${repo_sha:0:7}
          echo "##vso[task.setvariable variable=DOCKER_TAG;isOutput=true]$(manual.branch.prefix)-${branch_name}-${docker_image_tag_sha}"
        displayName: 'Get Docker Tag (manual push)'
        name: 'getDockerTag1'
        condition: and(ne(variables['Build.SourceBranch'], 'refs/heads/develop'), eq(variables['Build.Reason'], 'Manual'))
      - bash: |
          env
          echo "SourceBranchName is $(Build.SourceBranchName)"
          echo "1 is $GETDOCKERTAG1_DOCKER_TAG"
          echo "2 is $GETDOCKERTAG2_DOCKER_TAG"
          echo "combined is $GETDOCKERTAG1_DOCKER_TAG$GETDOCKERTAG2_DOCKER_TAG"
          echo "##vso[task.setvariable variable=DOCKER_TAG;isOutput=true]$GETDOCKERTAG1_DOCKER_TAG$GETDOCKERTAG2_DOCKER_TAG"
        name: 'getDockerTag'
      - task: Docker@1
        displayName: 'Build main image'
        inputs:
          imageName: '$(application.name):$(getDockerTag.DOCKER_TAG)'
          arguments: '--build-arg APPVERSION=$(getDockerTag.DOCKER_TAG) --build-arg APP_BUILD_TAG=$(Build.SourceBranchName)-$(Build.SourceVersion) --build-arg APP_GIT_COMMIT=$(Build.SourceVersion)'
      - task: Docker@1
        displayName: 'Tag main image'
        inputs:
          azureSubscriptionEndpoint: '$(azure.subscription.endpoint)'
          azureContainerRegistry: $(azure.container.registry)
          command: 'Tag image'
          imageName: '$(application.name):$(getDockerTag.DOCKER_TAG)'
      - script: |
          echo "before run 1"
          mv .dockerignore .dockerignore.backup && \
          cp Dockerfile.test.dockerignore .dockerignore && \
          SOURCE_DOCKER_IMAGE="$(application.name):$(getDockerTag.DOCKER_TAG)" docker-compose -p $(Build.BuildId) -f docker-compose-test.yml run --rm test && \
          rm .dockerignore && \
          mv .dockerignore.backup .dockerignore
          echo "after run 1"
        displayName: 'Run tests in docker'
      - script: |
          echo "before run 2"
          docker-compose -p $(Build.BuildId) -f docker-compose-test.yml down --rmi local -v
          echo "after run 2"
        condition: always()
        displayName: Cleanup
      - task: Docker@1
        displayName: 'Push main image'
        inputs:
          azureSubscriptionEndpoint: '$(azure.subscription.endpoint)'
          azureContainerRegistry: $(azure.container.registry)
          command: 'Push an image'
          imageName: '$(application.name):$(getDockerTag.DOCKER_TAG)'
        condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/develop'), eq(variables['Build.Reason'], 'Manual')))
      - task: Docker@1
        displayName: logout
        inputs:
          command: logout


# resources:
#   containers:

#   - container: postgres
#     image: postgres:11
#     env: { POSTGRES_HOST_AUTH_METHOD: trust }
#     ports:
#     - 5432:5432

# jobs:
#   - job: TestApplication

#     pool:
#       vmImage: 'Ubuntu-22.04'

#     services:
#       postgres: postgres
#     variables:
#       rubyVersion: '= 3.1.4'
#       bundlerVersion: '2.3.10'
#       aptDependencies: 'xvfb postgresql-client libpq-dev'

#     steps:
#     - template: ./pipeline-steps/add-dependencies.yaml
#     - template: ./pipeline-steps/test-application.yaml
#     - template: ./pipeline-steps/publish-tests.yaml

#   - job: BuildAndPushImageCI

#     dependsOn: TestApplication
#     condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'), not(startsWith(variables['Build.SourceBranch'], 'refs/tags/')), ne(variables['Build.Reason'], 'Manual'))
#     pool:
#       vmImage: 'Ubuntu-22.04'

#     steps:
#     - template: ./pipeline-steps/docker-build.yaml
#       parameters:
#         azureContainerRegistry: $(azure.container.registry)
#         azureSubscriptionEndpoint: $(azure.subscription.endpoint)
#         applicationName: $(application.name)

#   - job: BuildAndPushImageRelease

#     dependsOn: TestApplication
#     condition: and(succeeded(), startsWith(variables['Build.SourceBranch'], 'refs/tags/'))
#     pool:
#       vmImage: 'Ubuntu-22.04'

#     steps:
#     - template: ./pipeline-steps/docker-build-release.yaml
#       parameters:
#         azureContainerRegistry: $(azure.container.registry)
#         azureSubscriptionEndpoint: $(azure.subscription.endpoint)
#         applicationName: $(application.name)


#   - job: BuildAndPushImageManual

#     dependsOn: TestApplication
#     condition: and(succeeded(), eq(variables['Build.Reason'], 'Manual'))
#     pool:
#       vmImage: 'Ubuntu-22.04'

#     steps:
#     - template: ./pipeline-steps/docker-build-manual.yaml
#       parameters:
#         azureContainerRegistry: $(azure.container.registry)
#         azureSubscriptionEndpoint: $(azure.subscription.endpoint)
#         manualBranchPrefix: $(manual.branch.prefix)
#         applicationName: $(application.name)
