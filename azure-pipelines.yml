# Ruby
# Package your Ruby project.
# Add steps that install rails, analyze code, save build artifacts, deploy, and more:
# https://docs.microsoft.com/azure/devops/pipelines/languages/ruby

name: '$(SourceBranchName)-$(Build.SourceVersion) Build-$(Build.BuildId)'

trigger:
  batch: true
  branches:
    include:
      - master
  tags:
    include:
    - v*

pr:
  autoCancel: true
  branches:
    include:
      - master
      - feature/*

variables:
  application.name: 'hwf-staff'
  azure.subscription.endpoint: 'hmcts-pet'
  manual.branch.prefix: 'master'
  source_image: 'ruby:3.2-alpine'
  GOVUK_NOTIFY_API_KEY: ''
  NOTIFY_COMPLETED_NEW_REFUND_TEMPLATE_ID: 'template1'
  NOTIFY_COMPLETED_ONLINE_TEMPLATE_ID: 'template2'
  NOTIFY_COMPLETED_PAPER_TEMPLATE_ID: 'template3'
  NOTIFY_COMPLETED_CY_NEW_REFUND_TEMPLATE_ID: 'template4'
  NOTIFY_COMPLETED_CY_ONLINE_TEMPLATE_ID: 'template5'
  NOTIFY_COMPLETED_CY_PAPER_TEMPLATE_ID: 'template6'

resources:
  containers:

  - container: postgres
    image: postgres:11
    env: { POSTGRES_HOST_AUTH_METHOD: trust }
    ports:
    - 5432:5432
jobs:
  - job: TestApplication

    pool:
      vmImage: 'Ubuntu-22.04'

    services:
      postgres: postgres
    variables:
      rubyVersion: '= 3.1.4'
      bundlerVersion: '2.3.10'
      aptDependencies: 'xvfb postgresql-client libpq-dev'
      source_image: 'ruby:3.2-alpine'

    steps:
      - bash: |
          repo_sha=$(git rev-parse --verify HEAD)
          docker_image_tag_sha=${repo_sha:0:7}
          echo "##vso[task.setvariable variable=DOCKER_TAG;isOutput=true]$(Build.SourceBranchName)-${docker_image_tag_sha}"
        displayName: 'Get Docker Tag'
        name: getDockerTag

      - task: Docker@1
        displayName: 'Build an image'
        inputs:
          Dockerfile: '**/Dockerfile.test'
          imageName: 'hwf-staff:$(getDockerTag.DOCKER_TAG)'
          command: 'build'

      - task: Docker@1
        displayName: 'Run an image'
        inputs:
          Dockerfile: '**/Dockerfile.test'
          imageName: 'hwf-staff:$(getDockerTag.DOCKER_TAG)'
          command: 'run'
          runInBackground: 'false'

      - task: PublishTestResults@2
        inputs:
          testResultsFormat: 'JUnit'
          testResultsFiles: '**/test-results.xml'
        condition: succeededOrFailed()




  - job: BuildAndPushImageCI

    dependsOn: TestApplication
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'), not(startsWith(variables['Build.SourceBranch'], 'refs/tags/')), ne(variables['Build.Reason'], 'Manual'))
    pool:
      vmImage: 'Ubuntu-22.04'

    steps:
    - template: ./pipeline-steps/docker-build.yaml
      parameters:
        azureContainerRegistry: $(azure.container.registry)
        azureSubscriptionEndpoint: $(azure.subscription.endpoint)
        applicationName: $(application.name)

  - job: BuildAndPushImageRelease

    dependsOn: TestApplication
    condition: and(succeeded(), startsWith(variables['Build.SourceBranch'], 'refs/tags/'))
    pool:
      vmImage: 'Ubuntu-22.04'

    steps:
    - template: ./pipeline-steps/docker-build-release.yaml
      parameters:
        azureContainerRegistry: $(azure.container.registry)
        azureSubscriptionEndpoint: $(azure.subscription.endpoint)
        applicationName: $(application.name)


  - job: BuildAndPushImageManual

    dependsOn: TestApplication
    condition: and(succeeded(), eq(variables['Build.Reason'], 'Manual'))
    pool:
      vmImage: 'Ubuntu-22.04'

    steps:
    - template: ./pipeline-steps/docker-build-manual.yaml
      parameters:
        azureContainerRegistry: $(azure.container.registry)
        azureSubscriptionEndpoint: $(azure.subscription.endpoint)
        manualBranchPrefix: $(manual.branch.prefix)
        applicationName: $(application.name)